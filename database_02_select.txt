2020. 03 .30. 월
1. 텍스트 파일을 이용해 sql 문 사용하기
외부에서 텍스트 파일을 만들어 놓고 사용할 수 있다.
mysql -u root -p mysql < CREATE_USER_EXAM.txt
해당 텍스트 파일(CREATE_USER_EXAM.txt)에 다 적어놓으면 된다.

2. 출력 리다이렉션을 이용해 결과문 텍스트 파일로 저장하기
mysql -u root -p mysql < show.txt > result.txt
출력 리다이렉션을 쓰면 해당 텍스트 파일(result.txt)로 저장이 된다.

cf) 만약 텍스트 파일에 오류가 있다면 위의 구문부터 차근차근 실행시키면서 
오류가 난 구문에서 정지하고 에러 메시지를 보여준다. 
즉 정상처리 가능하다가 오류가 나는 것이다.
출력 리다이렉션을 사용할 경우 정상처리 메시지만 파일로 가고, 
에러 메시지만 프롬프트 상에 출력된다.

3. 출력 리다이렉션 2>를 사용해 에러메시지 텍스트 파일로 저장하기
mysql -u root -p mysql < show.txt > result.txt 2>error.txt
을 사용하면 에러메시지는 콘솔로 출력되는 것이 아니라 error.txt 파일로 저장된다.

cf)입력, 출력 리다이렉션
stdin 0 :입력 
stdout 1 : 출력
stderr 2 : 에러

4. 출력 파일 하나에 결과를 모두 다 저장하기
mysql -u root -p mysql < show.txt > result.txt 2>&1
에러출력을 파일 디스크립터 1로 지정을 한것이다. 
(윈도우즈만 이렇게 써.... posix 계열은 걍 파일 명 다시 쓰면 된다.)
즉 표준출력을 내보내는 곳으로 에러도 같이 내보내라 라는 뜻이다.
파일 내에서 오류가 나는 즉시 바로 파일을 종료시켜 버린다.
즉 앞에서 오류가 나면 뒤의 구문들을 실행이 되지 않는다.

5. 질의어 설명 링크
https://mariadb.com/kb/en/sql-statements/
여기에 설명이 잘 나와 있으니 정독하도록 하자.
https://mariadb.com/kb/en/data-definition/

6. /*계정추가*/
CREATE user project IDENTIFIED BY '1234';
/*추가된 계정에 권한 부여*/
GRANT ALL PRIVILEGES ON project.* TO prject;
/*데이터베이스 생성*/
CREATE DATABASE project;*/

==============================================================
1. SHOW GRANTS [FOR user]
현재 접속한 유저의 권한을 보여준다.

2. REVOKE ALL PRIVILEGES, GRANT OPTION FROM user [, user] ...
주었던 권한을 뺏기.

3. 비밀번호 바꾸기.
SET PASSWORD [FOR user] =
    {
        PASSWORD('some password')
      | OLD_PASSWORD('some password')
      | 'encrypted password'
    }

4. DATABASE 와 SCHEMA 만들기
CREATE [OR REPLACE] {DATABASE | SCHEMA} [IF NOT EXISTS] db_name
    [create_specification] ...

5. DATABASE 와 SCHEMA 삭제하기
DROP {DATABASE | SCHEMA} [IF EXISTS] db_name

cf) Drop 하고 CREATE 하면 새로운 파일로 다시 만들수 있다.

cf) mysqladmin =관리자 계정, 모르면 --help, -? 치자

===================================================================
2020. 03 .31. 화
page 59

1. 외부스키마
테이블이 10개 라고 해서 다보여주는 것이 아니라
권한을 가지고 있는 일부만 보여주는 것이다.
개체와 개체간의 관계, (부모테이블과 자식테이블 간의 관계)
같은 데이타베이스에서도 다른 관점들....
일반 사용자는 질의어 이용해 사용 

2. 개념스키마
조직전체의 데이타베이스로 하나만 존재한다.
기관이나 조직의 관점들(업무적인 관점에서 본 스키마). 보통의 스키마가 개념스키마이다.
업무를 중심으로 스키마를 구성해야한다.

3. 내부스키마
물리적인 구조를 정의 
물리적 저장장치의 입장
데이터 항목의 표현방법, 레코드의 물리적 순서.
설계자 및 프로그래머가 보는 관점.

page 165

4. 스키마란.
한마디로 스키마는 명세이다. 개체와 개체들 개체와 개체가 가지는 속성, 
컬럼 테이블 간의 관계들을 명세화 시키는게 스키마이다.

page 61
5. 테이블 자체가 관계.
하나의 테이블이 하나의 업무, 개체, 데이타의 집합소.라고 보면된다.
column row는 논리적인 명칭
record, field 는 물리적인 명칭
각 column들의 집합이 행.
모델링 관점에서는 테이블이 개체.
테이블에는 관계있는 속성들이 있다. 즉 테이블자체가 관계.
하나의 행의 하나의 속성 = 필드라고 한다.
하나의 라인이 하나의 레코드....하지만 row column이라고 사용하자

6. 속성의 수를 차수라고 하는데, 트리에서도 자식의 수를 차수라고 한다.
즉 user라는 개체는 host, user, password등 다양한 자식들을 두고 있는 것이다.
테이블이 부모, 테이블에 딸려있는 속성들이 자식.

7. 튜플은 가지고올 대상에서 가지고 올때, 결과는 행렬이라고 부르면 된다.

8. 전체행의 수를 가리켜서 카디널리티라고 한다.

===================================================================
page113

<실습>
-삭제
DROP TABLE if EXISTS members;
-생성
CREATE TABLE members(
id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY, - 행을 대표하는 대표 식별자, 자동으로 인덱스, 자동으로 유니크 걸린다.
mname VARCHAR(20) NOT NULL,
pass VARCHAR(20) NOT NULL, 
email VARCHAR(50) NOT NULL UNIQUE,
regdate DATETIME NOT NULL DEFAULT NOW()
) ENGINE=INNODB DEFAULT CHARSET=UTF8;
--------------------------------------------
-삽입
INSERT INTO 
members(id, mname, pass, email, regdate) 
VALUES (DEFAULT, 'RM', '1234', 'rm@gmail.com', DEFAULT);
-확인하기
SELECT * FROM members;
--------------------------------------------
-테이블 생성
CREATE TABLE grades(
g_code CHAR(1) NOT NULL PRIMARY KEY,
g_name VARCHAR(20) NOT NULL, 
discount TINYINT NOT NULL DEFAULT 0
) ENGINE=INNODB DEFAULT CHARSET=UTF8;
--------------------------------------------
-삽입
INSERT INTO grades VALUES ('V', 'jin', 20);
INSERT INTO grades VALUES ('G', 'Suga', 20);
INSERT INTO grades VALUES ('S', 'RM', 20);
-해당 테이블 명세 출력
DESC members;
--------------------------------------------
-타 테이블의 요소로 테이블 만들기
CREATE TABLE temp as SELECT mname, email FROM members;

>>제약사항은 안 따라오고 자료형과 이름만 따온다.
--------------------------------------------
-속성 출력하기
SHOW COLUMNS FROM temp;
--------------------------------------------
-테이블 생성
CREATE TABLE customer(
id INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY Key
) ENGINE=INNODB DEFAULT CHARSET=UTF8;
--------------------------------------------
-테이블 수정하기
ALTER TABLE customer ADD c_name VARCHAR(50) NULL;
ALTER TABLE customer ADD c_phone VARCHAR(50) NOT NULL;
--------------------------------------------
-명세 출력
DESC customer;
--------------------------------------------
-삽입
INSERT INTO customer(c_name, c_phone)
VALUES ('jin', '921201');
INSERT INTO customer(c_name, c_phone)
VALUES ('suga', '930309');
--------------------------------------------
-삭제하기
ALTER TABLE customer DROP c_name;
--------------------------------------------
-추가하기
ALTER TABLE customer ADD c_name VARCHAR(30) NOT NULL;
SELECT * FROM customer;

>>null을 지정하지 못하면 empty 상태로 추가된다.
--------------------------------------------
-삽입하는 속성의 위치 직접 지정하기.
ALTER TABLE customer Drop c_name;
ALTER TABLE customer ADD c_name VARCHAR(30) NOT NULL DEFAULT '입력요망' AFTER id;(first)
SELECT * FROM customer;
--------------------------------------------

ALTER TABLE customer MODIFY c_phone VARCHAR(30) NULL;


ALTER TABLE customer CHANGE c_phone c_tel VARCHAR(50) NOT NULL;

ALTER TABLE customer MODIFY c_tel VARCHAR(5) NOT NULL;
이렇게 수정 불가
문자열이 길다면 자를 수가 없기 때문이다.
자료형의 변환이 불가능한 자료형으로 변환 시도...ㄴㄴ


page 77
주키는 테이블 내에 있는 행을 대표하는 키이다.
한행을 대표하는 키이다.(기본키)
참조키는 다른 테이블의 주키를 참조하게 된다.
check는 입력되는 값을 확인한다.
조건이 만족이 될시 값을 삽입한다.

복수키 프라이머리키는 한테이블에 2개 이상있을 수 없덩
자동으로 인덱스가 적용되어 검색속도가 빨라지지만, 전체적인 데이타베이스의 부하가 높아진다.
다중키 멀티키 속성 두개로 주키가 된다.

주키 지정하는 방법
1.
DROP TABLE if EXISTS test;
CREATE TABLE test(
num INT NOT NULL PRIMARY key,
t_name VARCHAR(20) NOT NULL
)ENGINE=INNODB DEFAULT CHARSET=UTF8;
DESC test;
2.
DROP TABLE if EXISTS test;
CREATE TABLE test(
num INT NOT NULL,
t_name VARCHAR(20) NOT NULL,
PRIMARY KEY(num)
)ENGINE=INNODB DEFAULT CHARSET=UTF8;
DESC test;
3.
DROP TABLE if EXISTS test;
CREATE TABLE test(
num INT NOT NULL,
t_name VARCHAR(20) NOT NULL
)ENGINE=INNODB DEFAULT CHARSET=UTF8;
ALTER TABLE test ADD PRIMARY KEY(num);
DESC test;

주키 없애기
ALTER TABLE test DROP PRIMARY KEY;


ALTER TABLE test ADD PRIMARY KEY(num);
SELECT * FROM test;

다중키 만들기
CREATE TABLE board(
num INT Unsigned NOT NULL,
subnum INT Unsigned NOT NULL,
PRIMARY KEY(num, subnum)
)ENGINE=


ALTER TABLE board add PRIMARY KEY(num, subnum);





=========참조키
DROP TABLE mobile;

CREATE TABLE mobile(
id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY, 
typename Varchar(20)	NOT NULL,
memberid INT UNSIGNED not NULL 
)ENGINE=INNODB DEFAULT CHARSET=UTF8;

ALTER TABLE mobile ADD  FOREIGN KEY (memberid)
REFERENCES members(id);

SELECT * FROM members;
DESC mobile;
INSERT INTO mobile(typename, memberid)VALUES ('grander',3);
INSERT INTO mobile VALUES (DEFAULT, 'sonata',1);
SELECT * FROM mobile;

참조의 무결성이 보장이 된다.
외래키를 사용함으로써.
부모 테이블에 있는 값이 아닌 것으로 자식 테이블은 추가하지 못하고
자식테이블에 있는 부모테이블의 참조값은 함부로 삭제하거나 수정할 수 없다.

-----------



삭제했다가 다시 추가해도 그전에 입력 되었었던 값 뒤로 이어서 시리얼 넘버가 지정된다.
아이노디비를 쓰고 있어서 그럼
다른 데이터 베이스는 최대값 잘 맞춰서 들어간다.
오토 인크리먼트의 제약을 잘 살필것.

-------------------------------------
CREATE TABLE category(
c_code CHAR(2) NOT NULL PRIMARY KEY, 
c_name VARCHAR(200) NOT NULL)
ENGINE=INNODB DEFAULT CHARSET=UTF8;

CREATE TABLE ingredient(
i_code CHAR(2) NOT NULL PRIMARY KEY, 
i_name VARCHAR(200) NOT NULL)
ENGINE=INNODB DEFAULT CHARSET=UTF8;

CREATE TABLE product(
p_code CHAR(4) NOT NULL PRIMARY KEY, 
p_name VARCHAR(200) NOT NULL, 
c_code CHAR(2) NOT NULL,
i_code CHAR(2) NOT NULL)
ENGINE=INNODB DEFAULT CHARSET=UTF8;

INSERT INTO category VALUES ('00', '미분류');

ALTER TABLE product ADD FOREIGN KEY(c_code)
REFERENCES category(c_code)
ON DELETE RESTRICT
자식이 존재하는 한 삭제 불가

ALTER TABLE product ADD FOREIGN KEY(c_code)
REFERENCES category(c_code)
ON DELETE CASCADE
자식까지 다삭제할 것

ALTER TABLE product ADD FOREIGN KEY(c_code)
REFERENCES category(c_code)
ON DELETE RESTRICT
ON UPDATE CASCADE
자식의 것도 함께 업데이트 할것.

INSERT INTO category VALUES ('01', '빵');
INSERT INTO product VALUES ('p001', '고구마빵', '01', '00');

SELECT * FROM category;
SELECT * FROM product;

>>카테고리가 부모

DELETE FROM category WHERE c_code = '01';
>>거부가 된다 왜? 자식이 있기 때문이다.

UPDATE category SET c_code = '02'
WHERE c_code = '01';
>>업데이트 하기

DELETE FROM peoduc;
DELETE FROM category WHERE c_code = '02';
>>자식이 없어서 삭제가 가능해진다.

=============
SHOW CREATE TABLE product;

CREATE TABLE `product` (
  `p_code` char(4) NOT NULL,
  `p_name` varchar(200) NOT NULL,
  `c_code` char(2) NOT NULL,
  `i_code` char(2) NOT NULL,
  PRIMARY KEY (`p_code`),
  KEY `c_code` (`c_code`), <<인덱스키
  CONSTRAINT `product_ibfk_1` FOREIGN KEY (`c_code`) REFERENCES `category` (`c_code`) ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8
>>외랰키를 삭제해도 인덱스는 남아있다.
=========================
reference_option:
  RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT
  -------------------

ALTER TABLE product DROP FOREIGN KEY `product_ibfk_1`;

SHOW CREATE TABLE product;

CREATE TABLE `product` (
  `p_code` char(4) NOT NULL,
  `p_name` varchar(200) NOT NULL,
  `c_code` char(2) NOT NULL,
  `i_code` char(2) NOT NULL,
  PRIMARY KEY (`p_code`),
  KEY `c_code` (`c_code`)<<여전히 인덱스가 남아있다
) ENGINE=InnoDB DEFAULT CHARSET=utf8

ALTER TABLE product DROP KEY c_code;
>>인덱스키도 별도로 지워주는 작업이 필요하다.

ALTER TABLE product ADD FOREIGN KEY (c_code) 
REFERENCES category(c_code) 
ON DELETE RESTRICT 
ON UPDATE CASCADE
;

ALTER TABLE product ADD FOREIGN KEY(i_code)
REFERENCES ingredient(i_code)
ON UPDATE CASCADE;

INSERT INTO ingredient VALUES ('01', 'flour');
SELECT * FROM ingredient;

INSERT INTO category VALUES ('01', 'bread');
SELECT * FROM category;

INSERT INTO product VALUES (
'p001', 'melon', '01', '01');

==============
page 86

컬럼에 대해서 인덱스를 걸면 전체적인 데이터 속도는 줄지만 검색속도는 빨라진다.
결국은 주키도 유니크 유니크도 유니크.
다 인덱스가 걸리는거여.

SHOW INDEX FROM product;
현재 테이블에 걸려있는 모든 인덱스를 출력

인덱스를 사용한다면 되도록이면 검색량이 많은 열에 인덱스를 추가하는 것이 좋다.
그렇다고 varchar 에다가 걸면 안된다. 가변형이기 때문이다

외래키는 인덱스가 자동으로 드롭되지 않는다
따라서 직접적은로 삭제할 수 밖에 없는 상황이 온다.

====================
page 90

check는 값에 대한 판단이다.

CREATE TABLE book(
id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY, 
title VARCHAR(200) NOT NULL, 
price MEDIUMINT UNSIGNED NOT NULL DEFAULT 0,
CHECK (price BETWEEN 0 AND 1000000))
ENGINE=INNODB DEFAULT CHARSET=UTF8; 

INSERT INTO book VALUES (DEFAULT, 'java', 10000);

CREATE TABLE courses(
id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY, 
c_name VARCHAR(200) NOT NULL, 
ctype CHAR(10) NOT NULL,
CHECK(ctype IN('전문가과정', '학생과정', '일반인과정')))
ENGINE INNODB DEFAULT CHARSET=UTF8;

INSERT INTO courses VALUES(DEFAULT, '자바프로그램', '일반인과정');

SHOW CREATE table courses;

CREATE TABLE `courses` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `c_name` varchar(200) NOT NULL,
  `ctype` char(10) NOT NULL,
  PRIMARY KEY (`id`),
  CONSTRAINT `CONSTRAINT_1` CHECK (`ctype` in ('전문가과정','학생과정','일반인과정'))
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8

ALTER TABLE courses DROP CONSTRAINT CONSTRAINT_1;
<<제약사항을 없애기
ALTER TABLE courses ADD CHECK (ctype IN ('전문가과정', '학생과정', '일반인과정'));
<<제약사항을 다시 추가하기

==============SELECT==========================
SELECT
    [ALL | DISTINCT(중복제거) | DISTINCTROW]
    [HIGH_PRIORITY]
    [STRAIGHT_JOIN]
    [SQL_SMALL_RESULT] [SQL_BIG_RESULT] [SQL_BUFFER_RESULT]
    [SQL_CACHE | SQL_NO_CACHE] [SQL_CALC_FOUND_ROWS]
    select_expr [, select_expr ...]
    [ FROM table_references(써도 되고 맘대루)
      [WHERE where_condition]
      [GROUP BY {col_name | expr | position} [ASC | DESC], ... [WITH ROLLUP]]
      [HAVING where_condition]
      [ORDER BY {col_name | expr | position} [ASC | DESC], ...]
      [LIMIT {[offset,] row_count | row_count OFFSET offset}]
      procedure|[PROCEDURE procedure_name(argument_list)]
      [INTO OUTFILE 'file_name' [CHARACTER SET charset_name] [export_options]


INTO DUMPFILE 'file_name'	INTO var_name [, var_name] ]

      [[FOR UPDATE | LOCK IN SHARE MODE] [WAIT n | NOWAIT] ] ]


export_options:
    [{FIELDS | COLUMNS}
        [TERMINATED BY 'string']
        [[OPTIONALLY] ENCLOSED BY 'char']
        [ESCAPED BY 'char']
    ]
    [LINES
        [STARTING BY 'string']
        [TERMINATED BY 'string']
    ]

--------------------------------------------------------
SELECT * FROM category;
SELECT NOW();
SELECT CEIL(3.1);
SELECT CEIL(3.1) FROM category;

SELECT CEIL(3.1) result FROM book;
SELECT CEIL(3.1) 'result value' FROM book;
>>결과를 출력하되 헤더를 result로 지정해라.

SELECT id, title, price FROM book;
->SELECT book.id, book.title, book.price FROM book;
->SELECT book.id, book.title, book.price FROM moosong.book;

->SELECT id '일련번호', title'책제목', price'가격' FROM book;
헤더를 바꾸어 출력하기

SELECT 뒤에 오는 것은 바로 수식이다.
따라서 뒤에 함수가 올수도, col 이 올수도 있는 것이다.

헤더를 알리아스??라고 한다.

SELECT id, title, price FROM book AS a;
이렇게 데이타베이스에도 닉네임을 붙여줄 수 있다.
-------------------------------------
<실습2>
DESC category;
DESC comics;
EXPLAIN comics_to_tags;
DESCRIBE members;
DESCRIBE publisher;
DESCRIBE ratings;
DESCRIBE tags;

SELECT category_code AS '분류코드', category_name AS '분류명'FROM category c;

SELECT category_code AS '분류코드', category_name AS '분류명'
FROM category c
WHERE category_code = 'ACTI';

SELECT category_name AS '분류명'
FROM category c
WHERE category_code = 'ACTI';

SELECT category_code AS '분류코드', category_name AS '분류명'
FROM category c
WHERE c.category_code = 'ACTI';

SELECT 
category_code AS '분류코드', 
category_name AS '분류명'
FROM category AS C
WHERE c.category_code = 'A%';>>오류발생
와일드 카드 쓸 수 없음.

SELECT 
category_code AS '분류코드', 
category_name AS '분류명'
FROM category AS C
WHERE c.category_code Like 'A%';
>>이렇게 바꾸어 써야 해결 가능.

SELECT 
category_code AS '분류코드', 
category_name AS '분류명'
FROM category AS C
WHERE c.category_code Not Like 'A%';
>>A로 시작하지 않는것.

SELECT 
category_code AS '분류코드', 
category_name AS '분류명'
FROM category AS C
WHERE c.category_code Not Like 'A___';
>>4문자이면서 A로 시작하지 않는것

SELECT 
	category_code AS '분류코드', 
	category_name AS '분류명'
FROM 
	category AS C
WHERE 
	c.category_code Not Like 'A___'
ORDER BY
	category_code DeSC;
>>내림차순 정렬

SELECT 
	category_code AS '분류코드', 
	category_name AS '분류명'
FROM 
	category AS C
WHERE 
	c.category_code Not Like 'A___'
ORDER BY
	category_code ASC;
>>오름차순 정렬

SELECT 
	category_code AS '분류코드', 
	category_name AS '분류명'
FROM 
	category AS C
WHERE 
	c.category_code Not Like 'A___'
ORDER BY
	category_code ASC
LIMIT 3;
>>상위 세개만 출력하라

SELECT 
	category_code AS '분류코드', 
	category_name AS '분류명'
FROM 
	category AS C
WHERE 
	c.category_code Not Like 'A___'
ORDER BY
	category_code ASC
LIMIT 0, 3;
>>0번째부터 세개만 출력

=================================
SELECT 
	id '일련번호', 
	comics_id '서적번호', 
	rating_count '판매수량', 
	rating_date '판매일자',
	rating_price '판매가격' ,
	rating_count*rating_price '총판매액'
FROM ratings
WHERE rating_count >= 10
ORDER BY rating_count DESC;

SELECT 
	id '일련번호', 
	comics_id '서적번호', 
	rating_count '판매수량', 
	rating_date '판매일자',
	rating_price '판매가격' ,
	rating_count*rating_price '총판매액'
FROM ratings
WHERE rating_count >= 10 || rating_price >=17000
ORDER BY rating_count DESC;
=====================================
cd C:\program

>mysqladmin -umoosong -p -h192.168.30.20 create moosong


SELECT COUNT(*) FROM comics;

SELECT category_code, COUNT(*)
FROM comics
GROUP BY category_code;

SELECT publisher_code, COUNT(*), MAX(price)
FROM comics
GROUP BY publisher_code;

SELECT publisher_code, COUNT(*), MAX(price)
FROM comics
GROUP BY publisher_code
HAVING COUNT(*)>=5
LIMIT 2;
